# Context
Обзорный вебинар об Context и как его лучше всего использовать в Go

## Вводная информация
Context в Go используется для синхронизации дедлайнов и сигналов остновки выполнения.
А так же для хранения информации спецефичной для запроса между процессами (горутинами)


## Иерархия работы контекста
.image content/tree.png 450 _

## Когда стоит использовать 

- Всегда стоит использовать вызовы withCancel, withDeadline, withTimeout (кроме самого первого)

- Будьте острожными , в качестве аргумента context.Context можно передать nil, так как это интерфейс
    в этом случае вы получите панику 

- withCancel возвращает ошибки. Обычно она опускается, так как обычно это заверешние работы сервиса 
  Но если у вас что-то иное - лучше проверить ошибку, потому что она может сигнализировать о том, что у вас остались не отмененённые процессы

- Задумывайтесь сколь долго должен жить процесс перед тем как передать туда контекст 

- Если у вас есть родительский и дочерний контекст чаще всего вам нужно отменять родительский, а не дочерний

## Когда стоит использовать 
- Проставляйте обоснованные deadline для контекстов withDeadline

- Не стоит хранить контексты в структурах. В языке принято передавать context первым аргументом, а через структуру 

- используйте http.NewRequestWithContext - такая функция сама соберёт все связанные с запросом объекты корректно 

- Все исходящие запросы из вашего сервиса должны принимать context

- Все входящие запросы в ваш сервис так же должны принимать context 

## Как работает отмена 
.code content/cancel.go 

## Минусы передачи value через context
- Во-первых, вы теряет плюсы проверки типов, потому что key and value в context - interface{}
- Ранее распечатывание context через метод String() могло привести к панике (если value не было thread-safe)
- не стоит писать собственные реализации context - вы не можете предсказать , как он будет работать в стандартной библиотеке 

## Замещение значений  
Хорошее правило для передачи value через контекста - это нечто очень верхеуровневое - userID, traceID и что-то такое очень высокого уровня

Всё что ниже - лучше этого избежать 

Потому что можно банально переписать значение , которое было выше 

.code content/double.go

## Опасность передачи контейнеров и указателей 
Если что-то , что вы положили в value не tread-safe - можно получить не то что вы ожидаете 

.code content/map.go

## Использование структур как ключей 
Да, это может казаться безумием, но такое можно написать 

.code content/struct.go

## Получение value не бесплатное 
И дело тут даже не в приведении типов , а просто операция в худшем случае равна O(N) 

.code content/value.go 

## Полезные ссылки 

1. [официальная документация с примерами](go.dev/blog/context)
 да, старая , но это было как раз когда их добавили. 

 Большая часть всё актуальная

 